{
  "Type": "AWS::Lambda::Function",
  "Properties": {
    "Code": {
      "ZipFile": "//\n//  index.js\n//  CompactConnect\n//\n//  Created by InspiringApps on 7/22/2024.\n//\n\n// ============================================================================\n//                               CONFIGURATION                                =\n// ============================================================================\n/**\n * Configuration of supported domains.\n * @type {object}\n */\nconst environment_values = {\n        webFrontend: `test-ui.example.com`,\n        dataApi: `test-api.example.com`,\n        s3UploadUrlState: `test-bulk-uploads-bucket-name.s3.amazonaws.com`,\n        s3UploadUrlProvider: `test-provider-users-bucket-name.s3.amazonaws.com`,\n        cognitoStaff: `test-staff-domain.auth.us-east-1.amazoncognito.com`,\n        cognitoProvider: `test-provider-domain.auth.us-east-1.amazoncognito.com`,\n};\n\n// ============================================================================\n//                                   HELPERS                                  =\n// ============================================================================\n/**\n * Get the request domain from the lambda event record.\n * @param  {object} eventRecord The cloudfront record from the lambda event.\n * @return {string}             The bare domain of the request domain.\n */\n\n/**\n * Get a fully qualified domain URI with the protocol scheme.\n * @param  {string} domain The bare domain string.\n * @return {string}        The fully-qualified domain string.\n */\nconst getFullyQualified = (domain) => {\n    const protocol = 'https://';\n    let fullyQualified = '';\n\n    if (domain && typeof domain === 'string' && !domain.startsWith(protocol)) {\n        fullyQualified = `${protocol}${domain}`;\n    }\n\n    return fullyQualified;\n};\n\n/**\n * Helper to get the fully-qualified domains for connected services based on the request domain.\n * @param  {string} requestDomain The bare domain of the request.\n * @return {object}               A map of fully-qualified domains for the request environment.\n *   @return {string} dataApi       The data API fully-qualified domain.\n *   @return {string} s3UploadUrlState      The S3 fully-qualified domain for uploading state files.\n *   @return {string} s3UploadUrlProvider      The S3 fully-qualified domain for uploading provider files.\n *   @return {string} cognitoStaff  The Cognito fully-qualified domain for authenticating staff users.\n */\nconst getEnvironmentUrls = () => {\n    const environmentUrls = {};\n\n    environmentUrls.dataApi = getFullyQualified(environment_values.dataApi);\n    environmentUrls.s3UploadUrlState = getFullyQualified(environment_values.s3UploadUrlState);\n    environmentUrls.s3UploadUrlProvider = getFullyQualified(environment_values.s3UploadUrlProvider);\n    environmentUrls.cognitoStaff = getFullyQualified(environment_values.cognitoStaff);\n    environmentUrls.cognitoProvider = getFullyQualified(environment_values.cognitoProvider);\n\n    return environmentUrls;\n};\n\n/**\n * Helper to escape CSP src keywords.\n * @param  {string} keyword The standard keyword value.\n * @return {string}         The escaped keyword value.\n */\nconst srcKeywordEscape = (keyword) => {\n    let escaped = '';\n\n    if (keyword && typeof keyword === 'string') {\n        escaped = `'${keyword}'`.toLowerCase();\n    }\n\n    return escaped;\n};\n\n/**\n * Helper to automatically escape and prep CSP src keyword values (by reference).\n * @param  {Array<string>} srcList       The CSP src list.\n * @param  {string}        [listName=''] Optional src list name for logging.\n */\nconst srcKeywordsEscape = (srcList, listName = '') => {\n    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy#keyword_values\n    const srcKeywordsConfig = [\n        { value: 'self', isAllowed: true },\n        { value: 'none', isAllowed: true },\n        { value: 'strict-dynamic', isAllowed: true },\n        { value: 'report-sample', isAllowed: true },\n        { value: 'inline-speculation-rules', isAllowed: true },\n        { value: 'unsafe-inline', isAllowed: false },\n        { value: 'unsafe-eval', isAllowed: false },\n        { value: 'unsafe-hashes', isAllowed: false },\n        { value: 'wasm-unsafe-eval', isAllowed: false },\n    ];\n    const srcKeywords = srcKeywordsConfig.map((config) => config.value.toLowerCase());\n\n    if (Array.isArray(srcList)) {\n        srcList.forEach((srcItem, idx) => {\n            const isString = typeof srcItem === 'string';\n\n            if (!isString) {\n                srcList[idx] = '';\n            } else {\n                const srcItemLowerCase = srcItem.toLowerCase();\n\n                if (srcKeywords.includes(srcItemLowerCase)) {\n                    const keywordConfig = srcKeywordsConfig.find(\n                        (config) => srcItemLowerCase === config.value.toLowerCase()\n                    );\n\n                    if (keywordConfig) {\n                        if (!keywordConfig.isAllowed) {\n                            console.warn(`${listName} ${srcItem} keyword is not allowed in srcKeywordsConfig policy. We likely should not be using this keyword for security reasons.`.trim());\n                            srcList[idx] = '';\n                        } else {\n                            srcList[idx] = srcKeywordEscape(srcItem);\n                        }\n                    }\n                }\n            }\n        });\n    }\n};\n\n/**\n * Helper to build a CSP src group list string from input params.\n * @param  {string}        name src name for the CSP group.\n * @param  {Array<string>} list The static src list for the CSP group.\n * @return {string}             The prepped src list string;\n */\nconst buildSrcString = (name = '', list = []) => {\n    let srcString = '';\n\n    if (Array.isArray(list)) {\n        srcKeywordsEscape(list, name);\n        srcString = `${name} ${list.join(' ')};`;\n    }\n\n    return srcString;\n};\n\n// ============================================================================\n//                               RESPONSE HEADERS                             =\n// ============================================================================\n/**\n * Set the CSP header on the response (by reference).\n * @param {string} requestDomain The domain making the request.\n * @param {object} [headers={}]  The event response headers (updated by reference).\n */\nconst setCspHeader = ( headers = {}) => {\n    const domains = getEnvironmentUrls();\n    const cognitoIdpUrl = 'https://cognito-idp.us-east-1.amazonaws.com';\n\n    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy\n    headers['content-security-policy'] = [{\n        key: 'Content-Security-Policy',\n        value: `${[\n            `default-src 'none';`,\n            buildSrcString('manifest-src', [\n                'self',\n            ]),\n            buildSrcString('script-src', [\n                'self',\n                'https://www.google.com/recaptcha/',\n                'https://www.gstatic.com/recaptcha/',\n            ]),\n            buildSrcString('script-src-elem', [\n                'self',\n                'https://www.google.com/recaptcha/',\n                'https://www.gstatic.com/recaptcha/',\n            ]),\n            buildSrcString('script-src-attr', [\n                'self',\n            ]),\n            buildSrcString('worker-src', [\n                'self',\n            ]),\n            buildSrcString('style-src', [\n                'self',\n                'https://fonts.googleapis.com',\n                'https://www.gstatic.com/recaptcha/',\n            ]),\n            buildSrcString('style-src-elem', [\n                'self',\n                'https://fonts.googleapis.com',\n            ]),\n            buildSrcString('style-src-attr', [\n                'self',\n            ]),\n            buildSrcString('font-src', [\n                'self',\n                'https://fonts.gstatic.com',\n            ]),\n            buildSrcString('img-src', [\n                'self',\n                'data:',\n                domains.dataApi,\n                'https://www.gstatic.com/recaptcha/',\n            ]),\n            buildSrcString('media-src', [\n                'self',\n                domains.dataApi,\n            ]),\n            buildSrcString('frame-src', [\n                'self',\n                'https://www.google.com/recaptcha/',\n                'https://recaptcha.google.com/recaptcha/',\n            ]),\n            buildSrcString('frame-ancestors', [\n                'none'\n            ]),\n            buildSrcString('object-src', [\n                'none',\n            ]),\n            buildSrcString('form-action', [\n                'none',\n            ]),\n            buildSrcString('connect-src', [\n                'self',\n                domains.dataApi,\n                domains.s3UploadUrlState,\n                domains.s3UploadUrlProvider,\n                domains.cognitoStaff,\n                domains.cognitoProvider,\n                cognitoIdpUrl,\n                'https://www.google.com/recaptcha/',\n            ]),\n        ].join(' ')}`,\n    }];\n};\n\n/**\n * Set security headers on the response (by reference).\n * @param {string} requestDomain The domain making the request.\n * @param {object} [headers={}]  The event response headers (updated by reference).\n */\nconst setSecurityHeaders = (headers = {}) => {\n    // Strict-Transport-Security\n    headers['strict-transport-security'] = [{\n        key: 'Strict-Transport-Security',\n        value: 'max-age=31536000; includeSubdomains; preload',\n    }];\n    // X-Content-Type-Options\n    headers['x-content-type-options'] = [{\n        key: 'X-Content-Type-Options',\n        value: 'nosniff',\n    }];\n    // X-Frame-Options\n    headers['x-frame-options'] = [{\n        key: 'X-Frame-Options',\n        value: 'DENY',\n    }];\n    // Referrer-Policy\n    headers['referrer-policy'] = [{\n        key: 'Referrer-Policy',\n        value: 'strict-origin-when-cross-origin',\n    }];\n    // Server\n    headers.server = [{\n        key: 'Server',\n        value: 'CompactConnect',\n    }];\n    // Content-Security-Policy\n    setCspHeader(headers);\n};\n\n// ============================================================================\n//                                 LAMBDA ENTRY                               =\n// ============================================================================\nexports.handler = async (event) => {\n    // https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/lambda-event-structure.html\n    const eventRecord = event?.Records[0]?.cf || {};\n    const response = eventRecord.response || {};\n    const responseHeaders = response.headers || {};\n\n    setSecurityHeaders(responseHeaders);\n\n    return response;\n};\n"
    },
    "Handler": "index.handler",
    "Role": {
      "Fn::GetAtt": [
        "CSPFunctionServiceRoleF0056565",
        "Arn"
      ]
    },
    "Runtime": "nodejs22.x"
  },
  "DependsOn": [
    "CSPFunctionServiceRoleF0056565"
  ],
  "Metadata": {
    "cdk_nag": {
      "rules_to_suppress": [
        {
          "reason": "This lambda is synchronous and would not benefit from a DLQ",
          "id": "HIPAA.Security-LambdaDLQ"
        },
        {
          "reason": "This is a lambda executing at CloudFront edge and has no access to sensitive data. There is no benefit to putting it inside a custom VPC",
          "id": "HIPAA.Security-LambdaInsideVPC"
        }
      ]
    }
  }
}
